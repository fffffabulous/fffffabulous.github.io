{"meta":{"title":"fffffabulous","subtitle":"","description":"","author":"fffffabulous","url":"http://fffffabulous.github.io","root":"/"},"pages":[{"title":"友情链接","date":"2019-12-06T13:41:11.827Z","updated":"2019-12-06T13:41:11.827Z","comments":true,"path":"links/index.html","permalink":"http://fffffabulous.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-12-06T13:39:02.693Z","updated":"2019-12-06T13:39:02.692Z","comments":false,"path":"repository/index.html","permalink":"http://fffffabulous.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-12-06T14:31:39.425Z","updated":"2019-12-06T14:31:39.425Z","comments":false,"path":"tags/index.html","permalink":"http://fffffabulous.github.io/tags/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-12-06T14:01:16.605Z","updated":"2019-12-06T14:01:16.605Z","comments":false,"path":"books/index.html","permalink":"http://fffffabulous.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-12-06T16:44:50.378Z","updated":"2019-12-06T16:44:50.378Z","comments":false,"path":"about/index.html","permalink":"http://fffffabulous.github.io/about/index.html","excerpt":"","text":"{ name: 'fffffabulou' gender: '男', profession: 'Web Developer &amp; Designer', experience: '1年', address: '广东省', education: '本科', github: 'https://github.com/fffffabulous', blog: 'http://fabulous528.club', email: 'luw0528@126.com', description: '致力于网站建设与前端用户体验设计', skills: [ ['Html', 'Javascript', 'Http', 'CSS', 'ES6', 'Node'], ['Webpack'], ['Less','Sass'], ['Git', 'SVN'], ['Vue'], ['webstorm', 'atom', 'vscode'], ] }"},{"title":"分类","date":"2019-12-06T20:41:22.823Z","updated":"2019-12-06T20:41:22.823Z","comments":false,"path":"categories/index.html","permalink":"http://fffffabulous.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"movie🎬","slug":"movie","date":"2019-09-07T04:13:36.000Z","updated":"2019-12-07T05:03:58.158Z","comments":true,"path":"电影🎬/movie/","link":"","permalink":"http://fffffabulous.github.io/%E7%94%B5%E5%BD%B1%F0%9F%8E%AC/movie/","excerpt":"","text":"光影时刻《海蒂与爷爷》 人至善，景至美，故事细腻，淳朴动人，人生本该如此，温情永存，何惧苦难？ 怂囧小赫 《钢琴家》 你叫什么名字？ 斯皮尔曼。斯皮尔曼，一个好钢琴家的名字。 次非 《去他妈的世界》 —Let’s get out of here.—Okay. MojoEl 《气球》 一个国家如果特别好，人们为什么宁愿冒着死的风险，也要往外面跑呢？ 闲云 《盗钥匙的方法》 想要努力的人不管是被丢到怎样糟糕的人生里都会变好的啊。 王大根","categories":[{"name":"电影🎬","slug":"电影🎬","permalink":"http://fffffabulous.github.io/categories/%E7%94%B5%E5%BD%B1%F0%9F%8E%AC/"}],"tags":[{"name":"movie","slug":"movie","permalink":"http://fffffabulous.github.io/tags/movie/"},{"name":"photo","slug":"photo","permalink":"http://fffffabulous.github.io/tags/photo/"}]},{"title":"Mac系统常用快捷键","slug":"my","date":"2019-04-06T17:59:26.000Z","updated":"2019-12-06T20:17:44.100Z","comments":true,"path":"mac/my/","link":"","permalink":"http://fffffabulous.github.io/mac/my/","excerpt":"","text":"Mac中主要有四个修饰键，分别是Command，Control，Option和Shift。 通用Command是Mac里最重要的修饰键，在大多数情况下相当于Windows下的Ctrl。所以以下最基本操作很好理解： Command + Z 撤销 Command + x 剪切 Command + c 拷贝 Command + v 粘贴 Command + A 全选（All） Command + S 保存（Save) Command + F 查找（Find） 截图 Command + Shift + 3 截取全部屏幕到文件 Command + Shift + Control + 3 截取全部屏幕到剪贴板 Command + Shift + 4 截取所选屏幕区域到一个文件，或按空格键仅捕捉一个窗口 Command + Shift + Control + 3 截取所选屏幕区域到剪贴板，或按空格键仅捕捉一个窗口 切换 Command + Tab 在应用程序间切换 Command + Shift + Tab 在应用程序间切换（反向） Command + ~ 在各应用中的窗口间切换 浏览器 Command + L 光标直接跳至地址栏 Command + Tab 转向下一个标签页 Control + Shift + Tab 转向上一个标签页 Command + '+'或'=' 放大页面 Command + '-' 缩小页面 应用程序中 Command + H 隐藏（Hide）当前正在运行的应用程序窗口 Command + Option + H 隐藏（Hide）其他应用程序窗口 Command + Q 退出（Quit）最前面的应用程序 Command + Shift + Z 重做，也就是撤销的逆向操作 Command + Tab 在打开的应用程序列表中转到下一个最近使用的应用程序，相当于Windows中（Alt+Tab） Command + Option + esc 打开“强制退出”窗口，如果有应用程序无响应，可在窗口列表中选择强制退出 文本处理 Command + B 切换所选文字粗体（Bold）显示 fn + Delete 相当于PC全尺寸键盘上的Delete，也就是向后删除 fn + ↑ 向上滚动一页（Page Up） fn + ↓ 向下滚动一页（Page Down） fn + ← 滚动至文稿开头（Home） fn + → 滚动至文稿末尾（End） Command + → 将光标移至当前行的行尾 Command + ← 将光标移至当前行的行首 Command + ↓ 将光标移至文稿末尾 Command + ↑ 将光标移至文稿开头 Option + → 将光标移至下一个单词的末尾 Option + ← 将光标移至上一个单词的开头 Option + ← 移至行或段落的开头","categories":[{"name":"mac","slug":"mac","permalink":"http://fffffabulous.github.io/categories/mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://fffffabulous.github.io/tags/mac/"}]},{"title":"函数防抖、函数节流","slug":"hello-world","date":"2019-01-06T12:48:44.000Z","updated":"2019-12-06T18:49:25.674Z","comments":true,"path":"前端/函数/hello-world/","link":"","permalink":"http://fffffabulous.github.io/%E5%89%8D%E7%AB%AF/%E5%87%BD%E6%95%B0/hello-world/","excerpt":"","text":"函数防抖当调用函数 n 秒后，才会执行该动作，若在这 n 秒内又调用该函数则将取消前一次并重新计算执行时间代码原理设定一个全局变量保存定时器，事件触发时，判断定时器是否存在，存在时，消除定时 器，不存在时，重新设定定时器，确保一段时间内，只存在一个定时器。伪代码function _log() { console.log('log') } function _debounce(fn, delay) { var timer = null return function() { timer &amp;&amp; clearTimeout(timer) timer = setTimeout(function() { fn() }, delay) } } window.onresize = _debounce(_log, 1000) 函数节流函数预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期代码原理定义一个时间周期，当调用动作频率小于定义的时间周期，则进入下一周期，不会频繁触发伪代码function _log() { console.log('log') } function _throttle(method, duration) { var begin = new Date() return function() { var _this = this, _args = arguments, current = new Date() if (current - begin &gt;= duration) { method.apply(_this, _args) begin = current } } } window.onresize = _throttle(_log, 1000)","categories":[{"name":"前端","slug":"前端","permalink":"http://fffffabulous.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"函数","slug":"前端/函数","permalink":"http://fffffabulous.github.io/categories/%E5%89%8D%E7%AB%AF/%E5%87%BD%E6%95%B0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://fffffabulous.github.io/tags/JavaScript/"}]},{"title":"实现bind函数","slug":"event","date":"2018-12-07T06:43:07.000Z","updated":"2019-12-07T07:06:41.842Z","comments":true,"path":"前端/event/","link":"","permalink":"http://fffffabulous.github.io/%E5%89%8D%E7%AB%AF/event/","excerpt":"","text":"const ensure = function(condition, message) { // 在条件不成立的时候, 输出 message if (!condition) { log('*** 测试失败', message) } else { log('+++ 测试成功') } } const bind = function(func, thisArgs, ...args) { /* 实现 bind 函数 func 是目标函数, thisArgs 是调用 bind 函数时提供的 this 值 简单来说, 当调用 bind 函数后, func 函数中 this 指向的值为 thisArgs ...args 是剩余参数, 通过 call 或者 apply 改变 this 的指向 */ let f = () =&gt; { return func.apply(thisArgs, args) } return f } const testBind = () =&gt; { const greeting = function() { return this.name } let o1 = { name: 'gw', } let o2 = { name: 'xc', } let a1 = { name: 'xiaogua', } let a2 = { name: 'guaxiao', } o1.greeting = greeting o2.greeting = greeting let f1 = bind(o1.greeting, a1) let f2 = bind(o2.greeting, a2) ensure(f1() === 'xiaogua', 'test1') ensure(f2() === 'guaxiao', 'test2') }","categories":[{"name":"前端","slug":"前端","permalink":"http://fffffabulous.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://fffffabulous.github.io/tags/JavaScript/"}]},{"title":"音乐播放器","slug":"index","date":"2018-12-07T05:20:07.000Z","updated":"2019-12-07T05:47:31.802Z","comments":true,"path":"uncategorized/index/","link":"","permalink":"http://fffffabulous.github.io/uncategorized/index/","excerpt":"","text":"MusicPlayer * { margin: 0; padding: 0; } html, body { height: 100%; background-color: #d2d5d6; } span { cursor: pointer; } .class-div-main { width: 440px; height: 530px; margin: 0 auto; background-color: #eef1f2; position: relative; top: 50%; transform: translateY(-50%); border-radius: 10px; box-shadow: 0px 6px 7px #999; } .class-div-picture { width: 100%; height: 270px; position: relative; background-repeat: no-repeat; background-position: center; background-size: cover; } .class-div-musicLyric { width: 100%; height: 230px; padding: 20px 0; background-color: rgba(100, 100, 100, 0.5); } .class-div-lyricView { display: none; height: 230px; overflow: hidden; } .class-ul-lyric { position: relative; transition: all 1s; } .class-ul-lyric li { padding: 5px 0 2px 0; position: relative; text-align: center; color: rgba(255, 255, 255, 0.6); font-size: 12px; transition: all 1s; } .class-ul-lyric li.active { font-size: 13px; color: #ffffff; } .class-div-musicplayer { height: 80px; width: 400px; padding: 20px 20px 0 20px; } .class-div-musicInfo { display: inline-block; width: 280px; } .class-div-musicInfo p { cursor: default; } .class-p-musicName, .class-p-author { font-weight: bold; color: #455569; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; } .class-p-musicName { font-size: 26px; } .class-p-author { font-size: 18px; } .class-span-outProgressbar, .class-span-inProgressbar { display: block; border: none; height: 6px; border-radius: 2px; } .class-span-outProgressbar { width: 400px; margin: 0 auto 10px auto; background-color: #414141; position: relative; } .class-span-inProgressbar { width: 0; background-color: #cdd2d7; } .class-div-controls { width: 400px; height: 50px; padding: 20px 20px; margin-top: 25px; } .class-div-musicCurrentTime { margin-left: 20px; margin-bottom: 20px; } #id-span-currentTime, #id-span-duration, .class-div-musicCurrentTime { cursor: default; } .class-div-playControls { position: relative; } .class-span-play, .class-span-next, .class-span-loop, .class-span-lyrics{ position: absolute; width: 28px; height: 28px; color: black; font-size: 45px; line-height: 25px; top: 50%; transform: translateY(-50%); } .class-span-next { left: 50px; } .class-span-loop { right: 16px; color: grey; } .class-span-lyrics { right: 70px; color: grey; } .class-span-loop-start { color: black; } .class-span-outSoundbar, .class-span-inSoundbar { display: block; position: absolute; top: 50%; transform: translateY(-50%); border: none; height: 8px; border-radius: 8px; } .class-div-soundControls { margin-top: 15px; margin-left: 20px; position: relative; } .class-span-outSoundbar { width: 80px; background-color: #414141; left: 20px; } .class-span-inSoundbar { width: 80px; background-color: #cdd2d7; } 00:00/00:00 const log = console.log.bind(console); const e = (selector) => { let element = document.querySelector(selector); return element }; const eAll = (selector) => { let elements = document.querySelectorAll(selector); return elements }; const bindEvent = (element, eventName, callback) => { element.addEventListener(eventName, function (event) { callback(event) }) }; const removeAllChild = (element) => { let elementSeletor = e(element); while (elementSeletor.hasChildNodes()) { elementSeletor.removeChild(elementSeletor.firstChild) } }; const removeAllClass = (className) => { let elements = eAll(\".\" + className); for (let i = 0; i < elements.length; i++) { let item = elements[i]; item.classList.remove(className) } }; var getIndexChild = (parent, index) => { let childrenArray = parent.children; return childrenArray[index] } const ajax = (request) => { let newRequest = new XMLHttpRequest(); let method = request.method; newRequest.open(method, request.url, true) let contentType = request.contentType; if (contentType !== undefined) { newRequest.setRequestHeader(\"Content-Type\", contentType) } newRequest.onreadystatechange = function () { if (newRequest.readyState === 4) { let response = newRequest.response; if (response.includes(\"error\")) { request.callback(\"error\") } else { let parseData = JSON.parse(newRequest.response); request.callback(parseData) } } } if (method === \"GET\") { newRequest.send() return } newRequest.send(request.data) }; const transFloatToTime = (floatNum) => { let f = Math.floor(floatNum); let minNum = Math.floor(f / 60); let secNum = f - minNum * 60; if (minNum < 10) { minNum = `0${minNum}` } if (secNum < 10) { secNum = `0${secNum}` } return `${minNum}:${secNum}` }; const switchPlayButtonIcon = (isPlaying) => { let playButton = e(\".class-span-play\") let classList = playButton.classList if (isPlaying) { classList.add(\"icon-zanting\") classList.remove(\"icon-bofang\") return } classList.add(\"icon-bofang\") classList.remove(\"icon-zanting\") }; const musicPlayEvent = (audioPlayer) => { audioPlayer.play() switchPlayButtonIcon(true) }; const musicPauseEvent = (audioPlayer) => { audioPlayer.pause() switchPlayButtonIcon(false) }; const bindPlayButtonEvent = () => { let playButton = e(\".class-span-play\") bindEvent(playButton, \"click\", function (event) { let audioPlayer = e(\"audio\") let isPausing = audioPlayer.paused if (isPausing) { musicPlayEvent(audioPlayer) return } musicPauseEvent(audioPlayer) }) }; const getRandomChannel = (response) => { let channelArray = response.channels let randomChannel = Math.floor(Math.random() * channelArray.length) let item = channelArray[randomChannel] let channelName = item.name let channelId = item.channel_id return { name: channelName, id: channelId, } }; const failToGetLyric = () => { let lyricUl = e(\".class-ul-lyric\") lyricUl.innerHTML = \"本歌曲展示没有歌词\" }; const getLyric = (sid) => { let newRequest = { method: \"POST\", url: `http://api.jirengu.com/fm/getLyric.php?&sid=${sid}`, callback: (response) => { if (response !== \"error\") { setLyric(response) return } failToGetLyric() } } ajax(newRequest) }; const setMusicPlayer = (song) => { let url = song.url let audioPlayer = e(\"audio\") let musicName = e(\".class-p-musicName\") let musicAuthor = e(\".class-p-author\") let musicDiv = e(\".class-div-picture\") audioPlayer.src = url musicName.innerHTML = song.title musicAuthor.innerHTML = song.artist musicDiv.style.backgroundImage = `url(${song.picture})` musicPlayEvent(audioPlayer) getLyric(song.sid) }; const setLyric = (response) => { removeAllChild(\".class-ul-lyric\") let line = response.lyric.split(\"\\n\") let result = handleLyric(line) renderLyric(result) }; const renderLyric = (result) => { let lyrLi = \"\" for (let i = 0; i < result.length; i++) { let item = result[i] lyrLi += `${item[1]}` } let lyrUl = e(\".class-ul-lyric\") lyrUl.innerHTML = lyrLi autoChangeLyr() }; const handleLyric = (line) => { let result = [] let timeReg = /\\[\\d{2}:\\d{2}.\\d{2}\\]/g for (let i = 0; i < line.length; i++) { let item = line[i] let time = item.match(timeReg) if (!time) { continue } let value = item.replace(timeReg, \"\") for (let j = 0; j < time.length; j++) { let t = time[j].slice(1, -1).split(\":\") let timeNum = parseInt(t[0], 10) * 60 + parseFloat(t[1]) result.push([timeNum, value]) } } result.sort((a, b) => { return a[0] - b[0] }) return result }; const autoChangeLyr = () => { let player = e(\"audio\") setInterval(() => { let lyrUl = e(\".class-ul-lyric\") let liHeight = getIndexChild(lyrUl, 5).clientHeight - 3 let liArray = lyrUl.children for (let i = 0; i < liArray.length - 1; i++) { let item = liArray[i] let currentTime = item.dataset.time let nextTime = liArray[i + 1].dataset.time let playerTime = player.currentTime if ((playerTime > currentTime) && (currentTime < nextTime)) { removeAllClass(\"active\") item.classList.add(\"active\") lyrUl.style.top = `${-(liHeight * (i - 2))}px` } } }, 100) }; const getChannelIdFromDataSet = () => { let musicInfoDiv = e(\".class-div-musicInfo\") let id = musicInfoDiv.dataset.channelId return id }; const requestMusic = (channelId) => { let musicRequest = { url: `http://api.jirengu.com/fm/getSong.php?channel=${channelId}`, method: \"GET\", callback: (response) => { let song = response.song[0] setMusicPlayer(song) } } ajax(musicRequest) }; const getMusicSource = () => { let channelRequest = { url: \"http://api.jirengu.com/fm/getChannels.php\", method: \"GET\", callback: (response) => { let singleChannel = getRandomChannel(response) let musicInfoDiv = e(\".class-div-musicInfo\") musicInfoDiv.dataset.channelId = singleChannel.id requestMusic(singleChannel.id) } } ajax(channelRequest) }; const autoEvent = (musicPlayer, inProgressBar) => { setInterval(() => { let length = musicPlayer.currentTime / musicPlayer.duration * 100 inProgressBar.style.width = `${length}%` }, 500) }; const barMouseDownEvent = (musicPlayer, outProgressBar, inProgressBar) => { bindEvent(outProgressBar, \"mousedown\", function (event) { let offset = event.offsetX let rangeX = offset / 400 musicPlayer.currentTime = musicPlayer.duration * rangeX }) }; const bindProgressBarEvent = () => { let musicPlayer = e(\"audio\") let inProgressBar = e(\".class-span-inProgressbar\") let outProgressBar = e(\".class-span-outProgressbar\") autoEvent(musicPlayer, inProgressBar) barMouseDownEvent(musicPlayer, outProgressBar, inProgressBar) }; const bindPlayerEndEvent = () => { let audioPlayer = e(\"audio\") bindEvent(audioPlayer, \"ended\", function (event) { let state = e(\".class-span-loop\").dataset.state if (state === \"open\") { audioPlayer.currentTime = 0 musicPlayEvent(audioPlayer) return } let id = getChannelIdFromDataSet() requestMusic(id) switchPlayButtonIcon(false) clearInterval(audioPlayer.dataset.currentTimeId) }) }; const bindNextSongEvent = () => { let nextSongButton = e(\".class-span-next\") bindEvent(nextSongButton, \"click\", function (event) { let id = getChannelIdFromDataSet() requestMusic(id) }) }; const changePlayerSound = (isSound) => { let musicPlayer = e(\"audio\") if (isSound) { let barSelector = e(\".class-span-inSoundbar\") let volumeNum = Number(barSelector.dataset.volume) musicPlayer.volume = volumeNum return } musicPlayer.volume = 0 }; const switchSoundIcon = (element) => { let state = element.dataset.state if (state === \"open\") { element.classList.remove(\"icon-yinliang\") element.classList.add(\"icon-jinying\") element.dataset.state = \"close\" changePlayerSound(false) return } element.classList.remove(\"icon-jinying\") element.classList.add(\"icon-yinliang\") changePlayerSound(true) element.dataset.state = \"open\" }; const bindSoundButtonEvent = () => { let soundButton = e(\".class-span-sound\") bindEvent(soundButton, \"click\", function (event) { let self = event.target switchSoundIcon(self) }) }; const bindSoundBarEvent = () => { let inSoundBar = e(\".class-span-inSoundbar\") let outSoundBar = e(\".class-span-outSoundbar\") bindEvent(outSoundBar, \"mousedown\", function (event) { let offset = event.offsetX inSoundBar.style.width = `${offset}.px` let soundButton = e(\".class-span-sound\") let soundState = soundButton.dataset.state if (soundState === \"open\") { let musicPlayer = e(\"audio\") let num = offset / 80 musicPlayer.volume = num inSoundBar.dataset.volume = num } }) }; const changeLoopButtonState = (loopButton) => { let state = loopButton.dataset.state if (state === \"close\") { loopButton.classList.add(\"class-span-loop-start\") loopButton.dataset.state = \"open\" return } loopButton.classList.remove(\"class-span-loop-start\") loopButton.dataset.state = \"close\" }; const bindLoopButtonEvent = () => { let loopButton = e(\".class-span-loop\") bindEvent(loopButton, \"click\", function (event) { let self = event.target changeLoopButtonState(self) }) }; const bindPlayEvents = () => { bindPlayButtonEvent() bindPlayerEndEvent() bindNextSongEvent() }; const bindSoundEvents = () => { bindSoundButtonEvent() bindSoundBarEvent() }; const autoChangeCurrentTime = (self, currentSelector, durationSelector) => { let durationTime = self.duration durationSelector.innerHTML = transFloatToTime(durationTime) let currentTimeId = setInterval(function() { let currentTime = transFloatToTime(self.currentTime) currentSelector.innerHTML = currentTime }, 1000) self.dataset.currentTimeId = currentTimeId }; const bindMusicCanPlayEvent = () => { let musicPlayer = e(\"audio\") let currentSelector = e(\"#id-span-currentTime\") let durationSelector = e(\"#id-span-duration\") bindEvent(musicPlayer, \"canplay\", function (event) { let self = event.target autoChangeCurrentTime(self, currentSelector, durationSelector) }) }; const bindLyrcButtonEvent = () => { let lyrcButton = e(\".class-span-lyrics\") let lyrcDiv = e(\".class-div-lyricView\") bindEvent(lyrcButton, \"click\", function (event) { let self = event.target if (self.style.color === \"grey\") { self.style.color = \"black\" lyrcDiv.style.display = \"block\" } else { self.style.color = \"grey\" lyrcDiv.style.display = \"none\" } }) }; const bindEvents = () => { bindMusicCanPlayEvent() bindPlayEvents() bindSoundEvents() bindProgressBarEvent() bindLoopButtonEvent() bindLyrcButtonEvent() }; const __main = () => { getMusicSource() bindEvents() }; __main()","categories":[],"tags":[{"name":"music","slug":"music","permalink":"http://fffffabulous.github.io/tags/music/"}]},{"title":"git生成ssh秘钥","slug":"code","date":"2018-11-06T12:48:44.000Z","updated":"2019-12-06T17:58:23.648Z","comments":true,"path":"前端/code/","link":"","permalink":"http://fffffabulous.github.io/%E5%89%8D%E7%AB%AF/code/","excerpt":"","text":"// 查看是否存在秘钥 $ cd ~/.ssh // 配置用户相关信息 $ git config –-global user.name ‘xxxxx’ $ git config –-global user.email ‘xxx@xx.xxx’ // 查看用户配置的相关信息 $ git config user.name $ git config user.email // 生成秘钥 (邮箱为上方配置的邮箱) $ ssh-keygen -t rsa -C ‘xxx@xx.xxx’ // 连按三个空格 Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/Mr.Yang/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /c/Users/Mr.Yang/.ssh/id_rsa. Your public key has been saved in /c/Users/Mr.Yang/.ssh/id_rsa.pub. The key fingerprint is: SHA256:zA6wNJrFB6NcqS6eBog/AHlzQuvFjYpG759Yhh1lWGI xxxxxx@xxxxx.xxx(上面自己的邮箱) The key\"s randomart image is: +---[RSA 2048]----+ | +E . | | ..+oo+ | | oo+*+.o | |o.*===+o | |==+*... S | |B.+.o .o | |++o. + . | | +o.+ . | |. o.o | +----[SHA256]-----+","categories":[{"name":"前端","slug":"前端","permalink":"http://fffffabulous.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"SSH","slug":"SSH","permalink":"http://fffffabulous.github.io/tags/SSH/"}]},{"title":"javascript中的 this","slug":"this","date":"2018-10-07T06:20:58.000Z","updated":"2019-12-07T06:39:28.690Z","comments":true,"path":"前端/this/","link":"","permalink":"http://fffffabulous.github.io/%E5%89%8D%E7%AB%AF/this/","excerpt":"","text":"你可能遇到过这样的 JS 面试题： var obj = { foo: function(){ console.log(this) } } var bar = obj.foo obj.foo() // 打印出的 this 是 obj bar() // 打印出的 this 是 window 请解释最后两行函数的值为什么不一样。 函数调用首先需要从函数的调用开始讲起。JS（ES5）里面有三种函数调用形式： func(p1, p2) obj.child.method(p1, p2) func.call(context, p1, p2) // 先不讲 apply 一般，初学者都知道前两种形式，而且认为前两种形式「优于」第三种形式。从看到这篇文章起，你一定要记住，第三种调用形式，才是正常调用形式： func.call(context, p1, p2) 其他两种都是语法糖，可以等价地变为 call 形式： func(p1, p2) 等价于 func.call(undefined, p1, p2) obj.child.method(p1, p2) 等价于 obj.child.method.call(obj.child, p1, p2) 请记下来。（我们称此代码为「转换代码」，方便下文引用）至此我们的函数调用只有一种形式 func.call(context, p1, p2) 这样，this 就好解释了this，就是上面代码中的 context。就这么简单。this 是你 call 一个函数时传的 context，由于你从来不用 call 形式的函数调用，所以你一直不知道。 先看 func(p1, p2) 中的 this 如何确定：当你写下面代码时 function func(){ console.log(this) } func() 等价于 function func(){ console.log(this) } func.call(undefined) // 可以简写为 func.call() 按理说打印出来的 this 应该就是 undefined 了吧，但是浏览器里有一条规则： 如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined） 因此上面的打印结果是 window。 如果你希望这里的 this 不是 window，很简单： func.call(obj) // 那么里面的 this 就是 obj 对象了 再看 obj.child.method(p1, p2) 的 this 如何确定 var obj = { foo: function(){ console.log(this) } } obj.foo() 按照「转换代码」，我们将 obj.foo() 转换为 obj.foo.call(obj) 好了，this 就是 obj。搞定。 回到题目： var obj = { foo: function(){ console.log(this) } } var bar = obj.foo obj.foo() // 转换为 obj.foo.call(obj)，this 就是 obj bar() // 转换为 bar.call() // 由于没有传 context // 所以 this 就是 undefined // 最后浏览器给你一个默认的 this —— window 对象 [ ] 语法function fn (){ console.log(this) } var arr = [fn, fn2] arr[0]() // 这里面的 this 又是什么呢？ 我们可以把 arr0 想象为arr.0( )，虽然后者的语法错了，但是形式与转换代码里的 obj.child.method(p1, p2) 对应上了，于是就可以愉快的转换了： arr[0]() 假想为 arr.0() 然后转换为 arr.0.call(arr) 那么里面的 this 就是 arr 了 :) 总结 this 就是你 call 一个函数时，传入的第一个参数。（请务必背下来「this 就是 call 的第一个参数」） 如果你的函数调用形式不是 call 形式，请按照「转换代码」将其转换为 call 形式。以后你遇到所有跟 this 有关的笔试题，都不会有疑问了。完。 链接：https://zhuanlan.zhihu.com/p/23804247","categories":[{"name":"前端","slug":"前端","permalink":"http://fffffabulous.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://fffffabulous.github.io/tags/JavaScript/"}]},{"title":"javascript 原型链","slug":"photo","date":"2018-10-06T19:30:05.000Z","updated":"2019-12-07T04:07:50.359Z","comments":true,"path":"前端/photo/","link":"","permalink":"http://fffffabulous.github.io/%E5%89%8D%E7%AB%AF/photo/","excerpt":"","text":"原型链 每个对象都可以有一个原型_proto_，这个原型还可以有它自己的原型， 以此类推，形成一个原型链。查找特定属性的时候，我们先去这个对象里去找， 如果没有的话就去它的原型对象里面去，如果还是没有的话再去向原型对象的原型对象里去寻找...... 这个操作被委托在整个原型链上，这个就是我们说的原型链了。prototype: prototype属性，它是函数所独有的，它是从一个函数指向一个对象。它的含义是函数的 原型对象，也就是这个函数（其实所有函数都可以作为构造函数）所创建的实例的原型对象; 这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我 们把这个对象叫做原型对象 _proto: __proto__ 是原型链查询中实际用到的，它总是指向 prototype，换句话说就是指向构造函 数的原型对象，它是对象独有的。注意，为什么Foo构造也有这个属性呢，因为再js的宇宙里万 物皆对象，包括函数； constructor: 每个函数都有一个原型对象，该原型对象有一个constructor属性，指向创建对象的函数本身。 结论: 1、_proto 是原型链查询中实际用到的，它总是指向 prototype； 2、prototype 是函数所独有的，在定义构造函数时自动创建，它总是被 proto 所指。 所有对象都有proto属性，函数这个特殊对象除了具有proto属性，还有特有的原型属性prototype。prototype对象默认有两个属性，constructor属性和proto属性。prototype属性可以给函数和对象添加可共享（继承）的方法、属性，而proto是查找某函数或对象的原型链方式。constructor，这个属性包含了一个指针，指回原构造函数。","categories":[{"name":"前端","slug":"前端","permalink":"http://fffffabulous.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://fffffabulous.github.io/tags/JavaScript/"}]},{"title":"冒泡排序 快速排序","slug":"func","date":"2018-09-06T17:01:19.000Z","updated":"2019-12-06T19:29:19.617Z","comments":true,"path":"前端/func/","link":"","permalink":"http://fffffabulous.github.io/%E5%89%8D%E7%AB%AF/func/","excerpt":"","text":"冒泡排序冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。 function buddle_sort(arr) { let len = arr.length - 1 for (let j = 0; j &lt; len; j++) { for (let i = 0; i &lt; len - j; i++) { if (arr[i] &gt; arr[i + 1]) { [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]] } } } } //对于冒泡排序来说，能不能传入第二个参数（参数为函数），来控制升序和降序？ function buddle_sort(arr, fn) { let len = arr.length while (len--) { for (let i = 0; i &lt; len; i++) { if (fn(arr[i], arr[i + 1]) &gt; 0) { [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]] } } } } 快速排序“快速排序”的思想很简单，整个排序过程只需要三步： （1）在数据集之中，选择一个元素作为”基准”（pivot）。 （2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。 （3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 const quickSort = (array) =&gt; { // 如果数组不足两个元素, 直接返回 if (array.length &lt; 2) { return array } // 找一个基准 let pivot = array[0] // 所有小于基准的放左边 let left = array.filter(e =&gt; e &lt; pivot) // 所有大于基准的放右边 let right = array.filter(e =&gt; e &gt; pivot) // 递归对 left 和 right 调用 quickSort 进行排序 return quickSort(left).concat([pivot]).concat(quickSort(right)) }","categories":[{"name":"前端","slug":"前端","permalink":"http://fffffabulous.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"封装","slug":"封装","permalink":"http://fffffabulous.github.io/tags/%E5%B0%81%E8%A3%85/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://fffffabulous.github.io/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"http://fffffabulous.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"AJAX的使用与封装","slug":"ajax","date":"2018-09-06T17:01:19.000Z","updated":"2019-12-06T17:57:52.631Z","comments":true,"path":"前端/ajax/","link":"","permalink":"http://fffffabulous.github.io/%E5%89%8D%E7%AB%AF/ajax/","excerpt":"","text":"// AJAX 和使用方法 // ajax 就是浏览器提供的用 js 获取链接内容的 API // 可以理解为发送网络请求的标准库 // 获取登录页面 // 创建 AJAX 对象 let r = new XMLHttpRequest() // 设置请求方法和请求地址 r.open('GET', '/login', true) // 注册响应函数 r.onreadystatechange = function() { console.log('state change', r) } // 发送请求 r.send() // 发送登录数据 let r = new XMLHttpRequest() // 设置请求方法和请求地址 r.open('POST', '/api/user/login', true) // 设置发送的数据的格式 r.setRequestHeader('Content-Type', 'application/json') // 注册响应函数 r.onreadystatechange = function() { if (r.readyState === 4) { console.log('state change', r, r.status, r.response) let response = JSON.parse(r.response) console.log('response', response) } else { console.log('change') } } // 发送请求 let account = { phone: 'gua', password: '123', } let data = JSON.stringify(account) r.send(data) // 可以封装成这样的一个函数 const ajax = (method, path, data, responseCallback) =&gt; { // 发送登录数据 let r = new XMLHttpRequest() // 设置请求方法和请求地址 r.open(method, path, true) // 设置发送的数据的格式 r.setRequestHeader('Content-Type', 'application/json') // 注册响应函数 r.onreadystatechange = function() { if (r.readyState === 4) { // console.log('state change', r, r.status, r.response) // let response = JSON.parse(r.response) // console.log('response', response) responseCallback(r.response) } else { console.log('change') } } r.send(data) }","categories":[{"name":"前端","slug":"前端","permalink":"http://fffffabulous.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://fffffabulous.github.io/tags/AJAX/"},{"name":"封装","slug":"封装","permalink":"http://fffffabulous.github.io/tags/%E5%B0%81%E8%A3%85/"}]},{"title":"闭包的理解","slug":"bibao","date":"2018-06-07T06:13:09.000Z","updated":"2019-12-07T06:18:56.230Z","comments":true,"path":"前端/bibao/","link":"","permalink":"http://fffffabulous.github.io/%E5%89%8D%E7%AB%AF/bibao/","excerpt":"","text":"JavaScript 闭包的本质源自两点，词法作用域和函数当作值传递。 词法作用域，就是，按照代码书写时的样子，内部函数可以访问函数外面的变量。引擎通过数据结构和算法表示一个函数，使得在代码解释执行时按照词法作用域的规则，可以访问外围的变量，这些变量就登记在相应的数据结构中。 函数当作值传递，即所谓的first class对象。就是可以把函数当作一个值来赋值，当作参数传给别的函数，也可以把函数当作一个值 return。一个函数被当作值返回时，也就相当于返回了一个通道，这个通道可以访问这个函数词法作用域中的变量，即函数所需要的数据结构保存了下来，数据结构中的值在外层函数执行时创建，外层函数执行完毕时理因销毁，但由于内部函数作为值返回出去，这些值得以保存下来。而且无法直接访问，必须通过返回的函数。这也就是私有性。 本来执行过程和词法作用域是封闭的，这种返回的函数就好比是一个虫洞，开了挂。 显然，闭包的形成很简单，在执行过程完毕后，返回函数，或者将函数得以保留下来，即形成闭包。实际上在 JavaScript 代码中闭包不要太常见。函数作为第一等对象之后 JavaScript 灵活得不要不要的。 作者：寸志链接：https://www.zhihu.com/question/34210214/answer/93590294","categories":[{"name":"前端","slug":"前端","permalink":"http://fffffabulous.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"闭包","slug":"闭包","permalink":"http://fffffabulous.github.io/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"HTTP","slug":"js","date":"2018-03-06T16:51:20.000Z","updated":"2019-12-06T17:57:04.736Z","comments":true,"path":"网络/js/","link":"","permalink":"http://fffffabulous.github.io/%E7%BD%91%E7%BB%9C/js/","excerpt":"","text":"电脑通信靠IP地址，IP地址记不住就发明了域名（domain name），然后电脑 自动向DNS服务器（domain name server）查询域名对应的IP地址 比如g.cn这样的网址，可以通过电脑的ping程序查出对应 IP 地址 ➜ ping g.cn PING g.cn (203.208.41.55): 56 data bytes 端口是什么？ 一个比喻： 用邮局互相写信的时候，ip相当于地址（也可以看做邮编，地址是域名） 端口是收信人姓名（因为一个地址比如公司、家只有一个地址，但是却可能有很多收信人） 端口就是一个标记收信人的数字。 端口是一个 16 位的数字，所以范围是 0-65535（2**16） 安全程度：Linux &gt; Mac &gt;&gt; Windows, iPhone &gt;&gt; Android ——HTTP协议—— 一个传输协议，协议就是双方都遵守的规范。 为什么叫超文本传输协议呢，因为收发的是文本信息。 1，浏览器（客户端）按照规定的格式发送文本数据（请求）到服务器 2，服务器解析请求，按照规定的格式返回文本数据（响应）到浏览器 3，浏览器解析得到的数据（响应），并做相应处理 请求和响应是一样的数据格式，分为 4 部分： 1，请求行或者响应行 2，Header（请求的 Header 中 Host 字段是必须的，其他都是可选） 3，\\r\\n\\r\\n（连续两个换行回车符，用来分隔Header和Body） 4，Body（可选） 请求的格式，注意大小写（这是一个不包含Body的请求）： 原始数据如下 'GET / HTTP/1.1\\r\\nhost:g.cn\\r\\n\\r\\n' 打印出来如下 GET / HTTP/1.1 host: g.cn 其中 1， GET 是请求方法（还有POST等，这就是个标志字符串而已） 2，/ 是请求的路径（这代表根路径） 3，HTTP/1.1 中，1.1是版本号，通用了20年 具体字符串是 'GET / HTTP/1.1\\r\\nhost:g.cn\\r\\n\\r\\n' 返回的数据(响应)如下 HTTP/1.1 301 Moved Permanently Alternate-Protocol: 80:quic,p=0,80:quic,p=0 Cache-Control: private, max-age=2592000 Content-Length: 218 Content-Type: text/html; charset=UTF-8 Date: Tue, 07 Jul 2015 02:57:59 GMT Expires: Tue, 07 Jul 2015 02:57:59 GMT Location: http://www.google.cn/ Server: gws X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block","categories":[{"name":"网络","slug":"网络","permalink":"http://fffffabulous.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://fffffabulous.github.io/tags/HTTP/"}]}]}