{"meta":{"title":"fffffabulous","subtitle":"","description":"","author":"fffffabulous","url":"http://fffffabulous.github.io","root":"/"},"pages":[{"title":"书单","date":"2019-12-06T14:01:16.605Z","updated":"2019-12-06T14:01:16.605Z","comments":false,"path":"books/index.html","permalink":"http://fffffabulous.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-12-06T16:44:50.378Z","updated":"2019-12-06T16:44:50.378Z","comments":false,"path":"about/index.html","permalink":"http://fffffabulous.github.io/about/index.html","excerpt":"","text":"{ name: 'fffffabulou' gender: '男', profession: 'Web Developer &amp; Designer', experience: '1年', address: '广东省', education: '本科', github: 'https://github.com/fffffabulous', blog: 'http://fabulous528.club', email: 'luw0528@126.com', description: '致力于网站建设与前端用户体验设计', skills: [ ['Html', 'Javascript', 'Http', 'CSS', 'ES6', 'Node'], ['Webpack'], ['Less','Sass'], ['Git', 'SVN'], ['Vue'], ['webstorm', 'atom', 'vscode'], ] }"},{"title":"友情链接","date":"2019-12-06T13:41:11.827Z","updated":"2019-12-06T13:41:11.827Z","comments":true,"path":"links/index.html","permalink":"http://fffffabulous.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-12-06T13:39:02.693Z","updated":"2019-12-06T13:39:02.692Z","comments":false,"path":"repository/index.html","permalink":"http://fffffabulous.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-12-06T14:31:39.425Z","updated":"2019-12-06T14:31:39.425Z","comments":false,"path":"tags/index.html","permalink":"http://fffffabulous.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-12-06T20:41:22.823Z","updated":"2019-12-06T20:41:22.823Z","comments":false,"path":"categories/index.html","permalink":"http://fffffabulous.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Mac系统常用快捷键","slug":"my","date":"2019-04-06T17:59:26.000Z","updated":"2019-12-06T20:17:44.100Z","comments":true,"path":"2019/04/07/my/","link":"","permalink":"http://fffffabulous.github.io/2019/04/07/my/","excerpt":"","text":"Mac中主要有四个修饰键，分别是Command，Control，Option和Shift。 通用Command是Mac里最重要的修饰键，在大多数情况下相当于Windows下的Ctrl。所以以下最基本操作很好理解： Command + Z 撤销 Command + x 剪切 Command + c 拷贝 Command + v 粘贴 Command + A 全选（All） Command + S 保存（Save) Command + F 查找（Find） 截图 Command + Shift + 3 截取全部屏幕到文件 Command + Shift + Control + 3 截取全部屏幕到剪贴板 Command + Shift + 4 截取所选屏幕区域到一个文件，或按空格键仅捕捉一个窗口 Command + Shift + Control + 3 截取所选屏幕区域到剪贴板，或按空格键仅捕捉一个窗口 切换 Command + Tab 在应用程序间切换 Command + Shift + Tab 在应用程序间切换（反向） Command + ~ 在各应用中的窗口间切换 浏览器 Command + L 光标直接跳至地址栏 Command + Tab 转向下一个标签页 Control + Shift + Tab 转向上一个标签页 Command + '+'或'=' 放大页面 Command + '-' 缩小页面 应用程序中 Command + H 隐藏（Hide）当前正在运行的应用程序窗口 Command + Option + H 隐藏（Hide）其他应用程序窗口 Command + Q 退出（Quit）最前面的应用程序 Command + Shift + Z 重做，也就是撤销的逆向操作 Command + Tab 在打开的应用程序列表中转到下一个最近使用的应用程序，相当于Windows中（Alt+Tab） Command + Option + esc 打开“强制退出”窗口，如果有应用程序无响应，可在窗口列表中选择强制退出 文本处理 Command + B 切换所选文字粗体（Bold）显示 fn + Delete 相当于PC全尺寸键盘上的Delete，也就是向后删除 fn + ↑ 向上滚动一页（Page Up） fn + ↓ 向下滚动一页（Page Down） fn + ← 滚动至文稿开头（Home） fn + → 滚动至文稿末尾（End） Command + → 将光标移至当前行的行尾 Command + ← 将光标移至当前行的行首 Command + ↓ 将光标移至文稿末尾 Command + ↑ 将光标移至文稿开头 Option + → 将光标移至下一个单词的末尾 Option + ← 将光标移至上一个单词的开头 Option + ← 移至行或段落的开头","categories":[{"name":"mac","slug":"mac","permalink":"http://fffffabulous.github.io/categories/mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://fffffabulous.github.io/tags/mac/"}]},{"title":"函数防抖、函数节流","slug":"hello-world","date":"2019-01-06T12:48:44.000Z","updated":"2019-12-06T18:49:25.674Z","comments":true,"path":"2019/01/06/hello-world/","link":"","permalink":"http://fffffabulous.github.io/2019/01/06/hello-world/","excerpt":"","text":"函数防抖当调用函数 n 秒后，才会执行该动作，若在这 n 秒内又调用该函数则将取消前一次并重新计算执行时间代码原理设定一个全局变量保存定时器，事件触发时，判断定时器是否存在，存在时，消除定时 器，不存在时，重新设定定时器，确保一段时间内，只存在一个定时器。伪代码function _log() { console.log('log') } function _debounce(fn, delay) { var timer = null return function() { timer &amp;&amp; clearTimeout(timer) timer = setTimeout(function() { fn() }, delay) } } window.onresize = _debounce(_log, 1000) 函数节流函数预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期代码原理定义一个时间周期，当调用动作频率小于定义的时间周期，则进入下一周期，不会频繁触发伪代码function _log() { console.log('log') } function _throttle(method, duration) { var begin = new Date() return function() { var _this = this, _args = arguments, current = new Date() if (current - begin &gt;= duration) { method.apply(_this, _args) begin = current } } } window.onresize = _throttle(_log, 1000)","categories":[{"name":"前端","slug":"前端","permalink":"http://fffffabulous.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"函数","slug":"前端/函数","permalink":"http://fffffabulous.github.io/categories/%E5%89%8D%E7%AB%AF/%E5%87%BD%E6%95%B0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://fffffabulous.github.io/tags/JavaScript/"}]},{"title":"git生成ssh秘钥","slug":"code","date":"2018-11-06T12:48:44.000Z","updated":"2019-12-06T17:58:23.648Z","comments":true,"path":"2018/11/06/code/","link":"","permalink":"http://fffffabulous.github.io/2018/11/06/code/","excerpt":"","text":"// 查看是否存在秘钥 $ cd ~/.ssh // 配置用户相关信息 $ git config –-global user.name ‘xxxxx’ $ git config –-global user.email ‘xxx@xx.xxx’ // 查看用户配置的相关信息 $ git config user.name $ git config user.email // 生成秘钥 (邮箱为上方配置的邮箱) $ ssh-keygen -t rsa -C ‘xxx@xx.xxx’ // 连按三个空格 Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/Mr.Yang/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /c/Users/Mr.Yang/.ssh/id_rsa. Your public key has been saved in /c/Users/Mr.Yang/.ssh/id_rsa.pub. The key fingerprint is: SHA256:zA6wNJrFB6NcqS6eBog/AHlzQuvFjYpG759Yhh1lWGI xxxxxx@xxxxx.xxx(上面自己的邮箱) The key\"s randomart image is: +---[RSA 2048]----+ | +E . | | ..+oo+ | | oo+*+.o | |o.*===+o | |==+*... S | |B.+.o .o | |++o. + . | | +o.+ . | |. o.o | +----[SHA256]-----+","categories":[{"name":"前端","slug":"前端","permalink":"http://fffffabulous.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"SSH","slug":"SSH","permalink":"http://fffffabulous.github.io/tags/SSH/"}]},{"title":"javascript 原型链","slug":"photo","date":"2018-10-06T19:30:05.000Z","updated":"2019-12-06T20:35:57.904Z","comments":true,"path":"2018/10/07/photo/","link":"","permalink":"http://fffffabulous.github.io/2018/10/07/photo/","excerpt":"","text":"原型链 每个对象都可以有一个原型_proto_，这个原型还可以有它自己的原型， 以此类推，形成一个原型链。查找特定属性的时候，我们先去这个对象里去找， 如果没有的话就去它的原型对象里面去，如果还是没有的话再去向原型对象的原型对象里去寻找...... 这个操作被委托在整个原型链上，这个就是我们说的原型链了。prototype: prototype属性，它是函数所独有的，它是从一个函数指向一个对象。它的含义是函数的 原型对象，也就是这个函数（其实所有函数都可以作为构造函数）所创建的实例的原型对象; 这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我 们把这个对象叫做原型对象 _proto: __proto__ 是原型链查询中实际用到的，它总是指向 prototype，换句话说就是指向构造函 数的原型对象，它是对象独有的。注意，为什么Foo构造也有这个属性呢，因为再js的宇宙里万 物皆对象，包括函数； constructor: 每个函数都有一个原型对象，该原型对象有一个constructor属性，指向创建对象的函数本身。 结论: 1、_proto 是原型链查询中实际用到的，它总是指向 prototype； 2、prototype 是函数所独有的，在定义构造函数时自动创建，它总是被 proto 所指。 所有对象都有proto属性，函数这个特殊对象除了具有proto属性，还有特有的原型属性prototype。prototype对象默认有两个属性，constructor属性和proto属性。prototype属性可以给函数和对象添加可共享（继承）的方法、属性，而proto是查找某函数或对象的原型链方式。constructor，这个属性包含了一个指针，指回原构造函数。","categories":[{"name":"前端","slug":"前端","permalink":"http://fffffabulous.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://fffffabulous.github.io/tags/JavaScript/"}]},{"title":"AJAX的使用与封装","slug":"ajax","date":"2018-09-06T17:01:19.000Z","updated":"2019-12-06T17:57:52.631Z","comments":true,"path":"2018/09/07/ajax/","link":"","permalink":"http://fffffabulous.github.io/2018/09/07/ajax/","excerpt":"","text":"// AJAX 和使用方法 // ajax 就是浏览器提供的用 js 获取链接内容的 API // 可以理解为发送网络请求的标准库 // 获取登录页面 // 创建 AJAX 对象 let r = new XMLHttpRequest() // 设置请求方法和请求地址 r.open('GET', '/login', true) // 注册响应函数 r.onreadystatechange = function() { console.log('state change', r) } // 发送请求 r.send() // 发送登录数据 let r = new XMLHttpRequest() // 设置请求方法和请求地址 r.open('POST', '/api/user/login', true) // 设置发送的数据的格式 r.setRequestHeader('Content-Type', 'application/json') // 注册响应函数 r.onreadystatechange = function() { if (r.readyState === 4) { console.log('state change', r, r.status, r.response) let response = JSON.parse(r.response) console.log('response', response) } else { console.log('change') } } // 发送请求 let account = { phone: 'gua', password: '123', } let data = JSON.stringify(account) r.send(data) // 可以封装成这样的一个函数 const ajax = (method, path, data, responseCallback) =&gt; { // 发送登录数据 let r = new XMLHttpRequest() // 设置请求方法和请求地址 r.open(method, path, true) // 设置发送的数据的格式 r.setRequestHeader('Content-Type', 'application/json') // 注册响应函数 r.onreadystatechange = function() { if (r.readyState === 4) { // console.log('state change', r, r.status, r.response) // let response = JSON.parse(r.response) // console.log('response', response) responseCallback(r.response) } else { console.log('change') } } r.send(data) }","categories":[{"name":"前端","slug":"前端","permalink":"http://fffffabulous.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://fffffabulous.github.io/tags/AJAX/"},{"name":"封装","slug":"封装","permalink":"http://fffffabulous.github.io/tags/%E5%B0%81%E8%A3%85/"}]},{"title":"冒泡排序 快速排序","slug":"func","date":"2018-09-06T17:01:19.000Z","updated":"2019-12-06T19:29:19.617Z","comments":true,"path":"2018/09/07/func/","link":"","permalink":"http://fffffabulous.github.io/2018/09/07/func/","excerpt":"","text":"冒泡排序冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。 function buddle_sort(arr) { let len = arr.length - 1 for (let j = 0; j &lt; len; j++) { for (let i = 0; i &lt; len - j; i++) { if (arr[i] &gt; arr[i + 1]) { [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]] } } } } //对于冒泡排序来说，能不能传入第二个参数（参数为函数），来控制升序和降序？ function buddle_sort(arr, fn) { let len = arr.length while (len--) { for (let i = 0; i &lt; len; i++) { if (fn(arr[i], arr[i + 1]) &gt; 0) { [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]] } } } } 快速排序“快速排序”的思想很简单，整个排序过程只需要三步： （1）在数据集之中，选择一个元素作为”基准”（pivot）。 （2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。 （3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 const quickSort = (array) =&gt; { // 如果数组不足两个元素, 直接返回 if (array.length &lt; 2) { return array } // 找一个基准 let pivot = array[0] // 所有小于基准的放左边 let left = array.filter(e =&gt; e &lt; pivot) // 所有大于基准的放右边 let right = array.filter(e =&gt; e &gt; pivot) // 递归对 left 和 right 调用 quickSort 进行排序 return quickSort(left).concat([pivot]).concat(quickSort(right)) }","categories":[{"name":"前端","slug":"前端","permalink":"http://fffffabulous.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"封装","slug":"封装","permalink":"http://fffffabulous.github.io/tags/%E5%B0%81%E8%A3%85/"},{"name":"算法","slug":"算法","permalink":"http://fffffabulous.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://fffffabulous.github.io/tags/JavaScript/"}]},{"title":"HTTP","slug":"js","date":"2018-03-06T16:51:20.000Z","updated":"2019-12-06T17:57:04.736Z","comments":true,"path":"2018/03/07/js/","link":"","permalink":"http://fffffabulous.github.io/2018/03/07/js/","excerpt":"","text":"电脑通信靠IP地址，IP地址记不住就发明了域名（domain name），然后电脑 自动向DNS服务器（domain name server）查询域名对应的IP地址 比如g.cn这样的网址，可以通过电脑的ping程序查出对应 IP 地址 ➜ ping g.cn PING g.cn (203.208.41.55): 56 data bytes 端口是什么？ 一个比喻： 用邮局互相写信的时候，ip相当于地址（也可以看做邮编，地址是域名） 端口是收信人姓名（因为一个地址比如公司、家只有一个地址，但是却可能有很多收信人） 端口就是一个标记收信人的数字。 端口是一个 16 位的数字，所以范围是 0-65535（2**16） 安全程度：Linux &gt; Mac &gt;&gt; Windows, iPhone &gt;&gt; Android ——HTTP协议—— 一个传输协议，协议就是双方都遵守的规范。 为什么叫超文本传输协议呢，因为收发的是文本信息。 1，浏览器（客户端）按照规定的格式发送文本数据（请求）到服务器 2，服务器解析请求，按照规定的格式返回文本数据（响应）到浏览器 3，浏览器解析得到的数据（响应），并做相应处理 请求和响应是一样的数据格式，分为 4 部分： 1，请求行或者响应行 2，Header（请求的 Header 中 Host 字段是必须的，其他都是可选） 3，\\r\\n\\r\\n（连续两个换行回车符，用来分隔Header和Body） 4，Body（可选） 请求的格式，注意大小写（这是一个不包含Body的请求）： 原始数据如下 'GET / HTTP/1.1\\r\\nhost:g.cn\\r\\n\\r\\n' 打印出来如下 GET / HTTP/1.1 host: g.cn 其中 1， GET 是请求方法（还有POST等，这就是个标志字符串而已） 2，/ 是请求的路径（这代表根路径） 3，HTTP/1.1 中，1.1是版本号，通用了20年 具体字符串是 'GET / HTTP/1.1\\r\\nhost:g.cn\\r\\n\\r\\n' 返回的数据(响应)如下 HTTP/1.1 301 Moved Permanently Alternate-Protocol: 80:quic,p=0,80:quic,p=0 Cache-Control: private, max-age=2592000 Content-Length: 218 Content-Type: text/html; charset=UTF-8 Date: Tue, 07 Jul 2015 02:57:59 GMT Expires: Tue, 07 Jul 2015 02:57:59 GMT Location: http://www.google.cn/ Server: gws X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block","categories":[{"name":"网络","slug":"网络","permalink":"http://fffffabulous.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://fffffabulous.github.io/tags/HTTP/"}]}]}